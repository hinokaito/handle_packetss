# 学習チェックリスト

---

## 1. Rust & Memory (低レイヤー実装力)
> Wasmで「10万個」を動かすための筋肉部分

### Ownership & Borrowing (所有権と借用)
- [ ] 所有権の基本概念を理解
- [ ] 借用 (`&` と `&mut`) のルールを理解
- [ ] ライフタイムの基礎を理解
- [ ] コンパイラエラーを自力で解決できる

### Memory Layout (メモリレイアウト)
- [ ] Stack vs Heap の違いを理解
- [ ] Data Locality (キャッシュ効率) を理解
- [x] Alignment と Padding を理解

### Data Oriented Design (データ指向設計)
- [ ] OOP との違いを理解
- [ ] Struct of Arrays (SoA) vs Array of Structs (AoS) を理解
- [ ] 実際にSoAパターンでコードを書く

### Zero-Copy Communication
- [ ] JS ⇔ Wasm 間のデータ共有方法を理解
- [ ] SharedArrayBuffer の使い方を学ぶ
- [ ] ポインタ渡しでの共有を実装

### Unsafe Rust
- [ ] 生ポインタ (`*const T`, `*mut T`) 操作を理解
- [ ] FFI (Foreign Function Interface) の基礎を学ぶ
- [ ] 安全なunsafeコードの書き方を習得

---

## 2. Graphics Programming (描画パイプライン)
> 「wgpu」を使ってGPUを叩くための知識

### Rendering Pipeline
- [ ] Vertex Shader (形を決める) の役割を理解
- [ ] Fragment Shader (色を塗る) の役割を理解
- [ ] パイプライン全体の流れを把握

### Instancing (インスタンシング) ⭐最重要
- [ ] インスタンシングの概念を理解
- [ ] 1回のドローコールで大量オブジェクトを描画する実装
- [ ] wgpuでのインスタンシング実装

### WGSL (WebGPU Shading Language)
- [ ] WGSLの基本構文を学ぶ
- [ ] 簡単なシェーダーを書く
- [ ] GPU並列計算の基礎を理解

### Linear Algebra (線形代数)
- [ ] Vector (位置・速度) の操作
- [ ] Matrix (回転・拡大縮小・カメラ変換) の操作
- [ ] Dot Product (内積) / Cross Product (外積) を理解

### Coordinate Systems
- [ ] Local Space → World Space 変換を理解
- [ ] World Space → Clip Space (画面座標) 変換を理解
- [ ] 座標変換を実装

---

## 3. Go & Concurrency (並行処理・サーバー)
> 大量のリクエストを捌く「シナリオ生成サーバー」を作るための脳みそ部分

### Goroutine Scheduler
- [ ] OSスレッドとGoroutineの関係 (M:Nモデル) を理解
- [ ] Goroutineが軽い理由を理解
- [ ] 切り替わりタイミングを理解

### Channel Patterns
- [ ] Fan-in パターンを実装
- [ ] Fan-out パターンを実装
- [ ] Worker Pool を実装
- [ ] Pipeline パターンを実装

### Sync Primitives
- [ ] `sync.WaitGroup` の使い方
- [ ] `sync.Mutex` の使い方
- [ ] atomic (CAS操作) を理解
- [ ] Race Condition を回避するコードを書く

### Context
- [ ] タイムアウト制御を実装
- [ ] キャンセルの伝播を理解
- [ ] グレースフルシャットダウンを実装

### Profiling
- [ ] pprof を使ったCPUプロファイル
- [ ] ヒープ割り当ての可視化

---

## 4. Network Protocols (通信プロトコル)
> 今回のテーマそのもの

### L4 Protocols
- [ ] TCP の仕組み (信頼性・順序制御・再送) を理解
- [ ] UDP の仕組み (投げっぱなし) を理解
- [ ] TCP vs UDP のビットレベルでの違いを理解

### QUIC / HTTP3
- [ ] QUICの基本概念を理解
- [ ] Head-of-Line Blocking 問題を理解
- [ ] UDPの上での再送制御・TLSを理解

### WebTransport
- [ ] WebSocketとの違いを理解
- [ ] ブラウザからQUIC (Datagram) を使うAPIを学ぶ

### Serialization
- [ ] JSON のパフォーマンス特性を理解
- [ ] Protobuf / MessagePack を学ぶ
- [ ] Custom Binary フォーマットを設計・実装
- [ ] エンディアン (Big/Little Endian) の変換を理解

### Packet Structure
- [ ] IPヘッダの構造を理解
- [ ] TTL, MTU, MSS を理解
- [ ] Checksum の役割を理解

---

## 5. Algorithms & Data Structures (計算量最適化)
> 「数が増えても遅くならない」ための魔法

### Spatial Partitioning (空間分割)
- [ ] Quadtree (四分木) を理解・実装
- [ ] Grid Partitioning を理解・実装
- [ ] 衝突判定を O(N²) → O(N) に最適化

### Load Balancing Algo
- [ ] Round Robin を理解
- [ ] Least Connections を理解
- [ ] Consistent Hashing (リングハッシュ) を理解

### Queuing Theory (待ち行列理論)
- [ ] バッファサイズ設計を理解
- [ ] Backpressure (背圧) 制御を実装

---

## 6. Architecture & DevOps (全体設計・運用)
> 「作ったものが正しく動く」状態を保つ技術

### Infrastructure as Code
- [ ] Docker (Multi-stage build) を習得
- [ ] Docker Compose でマルチコンテナ構成

### Git Strategy
- [ ] Conventional Commits を導入
- [ ] Feature Branch Workflow を実践

### Observability
- [ ] Metrics (Prometheus) を設定
- [ ] Structured Logging を実装
- [ ] Tracing を導入

### Design Patterns
- [ ] Backend for Frontend (BFF) パターンを理解
- [ ] Event-Driven Architecture を理解