# Padding

## What is it?
アライメントを満たすために挿入される詰め物のこと。

### What is a alignment
CPUが効率よくメモリにアクセスするための配置ルール。

### So what
フィールドの並び順でメモリ使用量が変わる。

## Why we should think alignment
CPUはメモリをワード単位で読み書きする。(64ビットCPUなら8バイト単位)
もしアライメントされてないとどうなるか？漫画に喩える。
2,4コマ漫画を集める漫画があったとして、漫画の構成は、左,右下と左,右上4つの枠で構成される。
もし、2コマ漫画→4コマ漫画という風に編集者が入れてしまった場合、読者は次のページを開く必要があるし、前後のページを脳内で合体させる必要がある。
2,2で構成するか、4のみで構成するのが合理的。CPUも同じように、メモリを合理的に置くことで効率的に使うべき。

## Again, What is the padding
```rust
struct MyData {
    a: u8;
    b: u64;
}
```
この場合、1バイト + 8バイトで9バイトになりそうだが、実際には16バイトになってしまう。
CPUは8バイトのものをずれた場所同士でマージしないといけない。
それは、同じ場所で完結するのと比較して遅くなる。そこでコンパイラが余白を入れることでマージする手間を与えなくする。その余白こそが、その名の通りパディング。
` a(1) + パディング(7) + b(8) = 16バイト`


| 型 | サイズ | アライメント | 配置可能アドレス |
| ---- | ---- | ---- | ---- |
| u8 / i8 | 1 byte | 1 byte | どこでもOK |
| u16 / i16 | 2 bytes | 2 bytes | 0, 2, 4, 6, 8... |
| u32 / i32 / f32 | 4 bytes | 4 bytes | 0, 4, 8, 12, 16... |
| u64 / i64 / f64 | 8 bytes | 8 bytes | 0, 8, 16, 24, 32... |
| u128 / i128 | 16 bytes | 8 or 16 bytes | プラットフォーム依存 |
| ポインタ（64bit）| 8 bytes | 8 bytes | 0, 8, 16, 24, 32... |


## What can we do
- 基本的に大きい順に並べる
- 同じサイズをグループ化させる
- 頻繁にアクセスするフィールドを近くに配置する
- マルチスレッドの場合、キャッシュラインを分離して境界までパディングで埋める
- プロトコル/フォーマット仕様に従う
- 同じサイズのフィールドが多い場合、論理的なグルーピングをする
- SIMDを使う場合、16/32バイト境界のアライメントを設ける
- Option/Resultのニッチ最適化を考慮する
- ABI互換性(FFI)を考慮する
#[repr(C)] を使わない限り、Rustコンパイラが自動最適化するので基本的に気にしなくてOK


## Why don't leave it compiler
- Wasm + JS 間のメモリ共有
- FFI（C/C++ライブラリとの連携）
- ネットワークプロトコルやファイルフォーマットの仕様準拠
これらの場合は期待する結果を出すために #[repr(C)] を使い、コンパイラの並べ替えを防ぐ必要がある。