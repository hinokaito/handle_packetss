# メモリアライメントとパディング戦略

## 基本概念
**メモリアライメント**とは、データをそのサイズ（または特定のワードサイズ）の倍数となるメモリアドレスに配置する制約のことです。

### なぜ重要か（パフォーマンスとコスト）
CPUはメモリをワードサイズ単位（例：64ビットシステムでは8バイト）でアクセスします。アライメントされていないアクセスは、CPUオーバーヘッド（1ワードではなく2ワードをフェッチ）を引き起こすか、一部のアーキテクチャ（ARM/SPARCなど）ではクラッシュの原因となります。

**大規模システムへの影響：**
1億レコードをメモリ上で処理するバックエンドシステムの場合：
- `BadLayout` (48バイト) × 1億 = 4.8 GB
- `GoodLayout` (32バイト) × 1億 = 3.2 GB
=> フィールドの並び替えだけで**1.6 GBのRAMを節約**。これはクラウドインフラコストに直接影響します。

## メンタルモデル：本棚のアナロジー
特定の幅（2cm、4cm）の本用に設計された本棚を想像してください。
4cmの本を3cmのオフセット位置から置くと、2つの「スロット」にまたがってしまいます。読むためには2つのスロットを見て、頭の中でつなぎ合わせる必要があります。
CPU（司書）は、即座にアクセスするために、本がスロット境界に揃っていることを好みます。「パディング」は、このルールを強制するために挿入される空のスペーサーです。

## パディングの可視化
例：`u8`（1バイト）の後に`u64`（8バイト）が続く場合。

```rust
struct MyData {
    a: u8,
    b: u64,
}
```

**実際のレイアウト（合計16バイト）：**

```
[a][.][.][.][.][.][.][.] [b][b][b][b][b][b][b][b]
 ^ a (1バイト)            ^ b (8バイト、8にアライン)
    ^ パディング (7バイト)
```

## アライメントルール早見表

| 型 | サイズ | 典型的なアライメント (x64) | 有効なオフセット |
|------|------|-------------------------|---------------|
| u8 / i8 | 1バイト | 1バイト | 任意 |
| u16 / i16 | 2バイト | 2バイト | 0, 2, 4... |
| u32 / f32 | 4バイト | 4バイト | 0, 4, 8... |
| u64 / f64 | 8バイト | 8バイト | 0, 8, 16... |
| u128 | 16バイト | 16バイト | 0, 16, 32... |

## 実践ガイドライン

### Rustコンパイラに任せる場合（デフォルト）

Rustのコンパイラは自動的にフィールドを並び替えてサイズを最小化します。

**つまり 基本的には何もしない。コンパイラを信頼する。**

### レイアウトを手動管理する場合 (#[repr(C)])

以下のシナリオでは手動でのレイアウト制御が必須です：

- **FFI (Foreign Function Interface)：** C/C++ライブラリに構造体を渡す場合。
- **ネットワークプロトコル：** 生のパケットバイトを構造体に直接マッピングする場合（TCP/QUICヘッダーのパースなど）。
- **ハードウェアドライバ：** 構造体を特定のメモリマップドレジスタにマッピングする場合。
- **Wasm共有メモリ：** RustとJavaScript/ブラウザ間でデータレイアウトを共有する場合。

これらの場合、パディングを最小化するためにフィールドをサイズ順（大きい順）に並べます。

