<!DOCTYPE html>
<!--
================================================================================
WebSocket + Wasm Demo - Frontend Application
================================================================================

This is the browser-based frontend for the packet traffic simulation.
It demonstrates the integration between:

  1. JavaScript (UI and WebSocket handling)
  2. Rust/WebAssembly (high-performance computation)
  3. Go Backend (WebSocket server)

Architecture:
============

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  This HTML File (Browser)                                           â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
  â”‚  â”‚  JavaScript      â”‚ â”€â”€â”€â”€â”€â”€>â”‚  Rust/Wasm Module                â”‚  â”‚
  â”‚  â”‚  - UI Controls   â”‚        â”‚  (simulation.wasm)               â”‚  â”‚
  â”‚  â”‚  - WebSocket     â”‚<â”€â”€â”€â”€â”€â”€ â”‚  - Message processing            â”‚  â”‚
  â”‚  â”‚  - Event Loop    â”‚        â”‚  - Simulation logic (TODO)       â”‚  â”‚
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
  â”‚           â”‚                                                         â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚ WebSocket (ws://localhost:8080/ws)
              â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Go Server (server/main.go)                                         â”‚
  â”‚  - WebSocket endpoint                                               â”‚
  â”‚  - Packet data streaming (TODO)                                     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Current Status (Step 1):
=======================

  [x] Wasm module loading and initialization
  [x] WebSocket connection management
  [x] UI for connection status and logging
  [x] Message passing between JS and Wasm
  [ ] WebGPU/WebGL canvas for visualization (TODO)
  [ ] Packet rendering (TODO)
  [ ] Simulation controls (TODO)

File Structure:
==============

  web/
  â”œâ”€â”€ index.html          <- This file
  â””â”€â”€ pkg/
      â”œâ”€â”€ simulation.js   <- Wasm loader (generated by wasm-bindgen)
      â”œâ”€â”€ simulation.wasm <- Compiled Rust code
      â””â”€â”€ simulation.d.ts <- TypeScript definitions

How to Run:
==========

  1. Start the Go server:
     $ cd server && go run main.go

  2. Serve this HTML file (e.g., using Python's http server):
     $ cd web && python -m http.server 3000

  3. Open http://localhost:3000 in your browser

  4. Click "Connect" to establish WebSocket connection

================================================================================
-->
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket + Wasm Demo</title>
    
    <!--
    ============================================================================
    STYLES
    ============================================================================
    
    The styling uses a dark theme inspired by GitHub's dark mode.
    CSS custom properties (variables) could be added for theme customization.
    
    Color palette:
    - Background: #0d1117 (deep dark blue)
    - Surface: #21262d (card backgrounds)
    - Border: #30363d (subtle borders)
    - Text: #c9d1d9 (primary text)
    - Accent: #58a6ff (links, highlights)
    - Success: #3fb950 (connected state)
    - Error: #f85149 (disconnected state)
    -->
    <style>
        /* ====================================================================
           RESET & BASE STYLES
           ==================================================================== */
        
        /* CSS Reset - Remove default browser styles for consistency */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box; /* Include padding/border in element size */
        }
        
        /* Base body styles */
        body {
            /* Font stack: Prefer monospace fonts for a "terminal" aesthetic */
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            
            /* Gradient background for visual depth */
            background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
            
            /* Light gray text color for readability on dark background */
            color: #c9d1d9;
            
            /* Ensure the page fills at least the viewport height */
            min-height: 100vh;
            
            /* Comfortable padding around content */
            padding: 2rem;
        }
        
        /* ====================================================================
           TYPOGRAPHY
           ==================================================================== */
        
        h1 {
            color: #58a6ff;        /* Blue accent color */
            margin-bottom: 1.5rem;
            font-size: 1.8rem;
        }
        
        /* ====================================================================
           LAYOUT
           ==================================================================== */
        
        /* Main container - centers content and limits max width */
        .container {
            max-width: 800px;
            margin: 0 auto;       /* Center horizontally */
        }
        
        /* ====================================================================
           CONNECTION STATUS INDICATOR
           ==================================================================== */
        
        /* Status bar showing connection state */
        .status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            background: #21262d;   /* Slightly lighter than body */
            border-radius: 6px;
            border: 1px solid #30363d;
        }
        
        /* Circular status indicator (red = disconnected) */
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;    /* Perfect circle */
            background: #f85149;   /* Red = disconnected */
        }
        
        /* Connected state - green with glow effect */
        .status-dot.connected {
            background: #3fb950;   /* Green = connected */
            box-shadow: 0 0 8px #3fb950; /* Subtle glow */
        }
        
        /* ====================================================================
           CANVAS CONTAINER (Step 3)
           ==================================================================== */
        
        /* Canvas wrapper for the packet visualization */
        .canvas-container {
            margin-bottom: 1rem;
            border: 1px solid #30363d;
            border-radius: 6px;
            overflow: hidden;
        }
        
        /* The actual canvas element */
        #packetCanvas {
            display: block;
            background: #0d1117;   /* Dark background */
            width: 100%;           /* Responsive width */
            height: auto;
        }
        
        /* ====================================================================
           PERFORMANCE STATS DISPLAY
           ==================================================================== */
        
        .stats {
            display: flex;
            gap: 1.5rem;
            padding: 0.75rem 1rem;
            background: #21262d;
            border-radius: 6px;
            border: 1px solid #30363d;
            margin-bottom: 1rem;
            font-size: 0.85rem;
        }
        
        .stats span {
            color: #8b949e;
        }
        
        .stats strong {
            color: #58a6ff;
            font-weight: bold;
        }
        
        /* ====================================================================
           LOG CONTAINER
           ==================================================================== */
        
        /* Scrollable log area showing connection events */
        .log-container {
            background: #0d1117;   /* Darkest background for contrast */
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 1rem;
            height: 200px;         /* Reduced height to make room for canvas */
            overflow-y: auto;      /* Enable vertical scrolling */
            font-size: 0.9rem;
        }
        
        /* Individual log entries */
        .log-entry {
            padding: 0.25rem 0;
            border-bottom: 1px solid #21262d;
        }
        
        /* Remove border from last entry */
        .log-entry:last-child {
            border-bottom: none;
        }
        
        /* Timestamp styling */
        .log-time {
            color: #8b949e;        /* Muted gray */
            margin-right: 0.5rem;
        }
        
        /* Source label (JS, Rust, WS) */
        .log-source {
            font-weight: bold;
            margin-right: 0.5rem;
        }
        
        /* Color-coded source labels */
        .log-source.js { color: #f0e68c; }   /* Yellow for JavaScript */
        .log-source.rust { color: #dea584; } /* Orange for Rust/Wasm */
        .log-source.ws { color: #a5d6ff; }   /* Light blue for WebSocket */
        
        /* ====================================================================
           CONTROL BUTTONS
           ==================================================================== */
        
        .controls {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;           /* Space between buttons */
        }
        
        /* Base button styles */
        button {
            padding: 0.5rem 1rem;
            background: #238636;   /* Green background */
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;  /* Use the same monospace font */
            font-size: 0.9rem;
            transition: background 0.2s; /* Smooth hover effect */
        }
        
        /* Button hover state */
        button:hover {
            background: #2ea043;   /* Slightly lighter green */
        }
        
        /* Disabled button state */
        button:disabled {
            background: #21262d;   /* Dark gray */
            color: #8b949e;        /* Muted text */
            cursor: not-allowed;   /* Show "no" cursor */
        }
    </style>
</head>
<body>
    <!-- ====================================================================
         MAIN CONTAINER
         ====================================================================
         
         The container holds all UI elements:
         - Title
         - Connection status indicator
         - Log display area
         - Control buttons
    -->
    <div class="container">
        <!-- Page title with emoji for visual interest -->
        <h1>ðŸ”Œ WebSocket + Wasm Demo</h1>
        
        <!-- Connection Status Indicator
             Shows a colored dot and text indicating WebSocket connection state.
             JavaScript updates these elements when connection state changes.
        -->
        <div class="status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Disconnected</span>
        </div>
        
        <!-- Canvas Container (Step 3)
             Displays the packet visualization.
             White squares are drawn at (x, y) coordinates received from the server.
        -->
        <div class="canvas-container">
            <canvas id="packetCanvas" width="800" height="600"></canvas>
        </div>
        
        <!-- Performance Stats Display -->
        <div class="stats" id="statsContainer">
            <span>Packets: <strong id="packetCount">0</strong></span>
            <span>JSON Size: <strong id="jsonSize">0 KB</strong></span>
            <span>Draw Time: <strong id="drawTime">0ms</strong></span>
        </div>
        
        <!-- Log Container
             Displays timestamped messages from JavaScript, Rust/Wasm, and WebSocket.
             Auto-scrolls to show latest messages.
        -->
        <div class="log-container" id="logContainer"></div>
        
        <!-- Control Buttons
             - Connect: Toggles WebSocket connection (Connect/Disconnect)
             - Send Test: Sends a test message to the server (disabled when not connected)
             - Clear: Clears the canvas
        -->
        <div class="controls">
            <button id="connectBtn">Connect</button>
            <button id="sendBtn" disabled>Send Test</button>
            <button id="clearBtn">Clear Canvas</button>
        </div>
    </div>

    <!-- ====================================================================
         JAVASCRIPT APPLICATION
         ====================================================================
         
         This script handles:
         1. Wasm module initialization
         2. WebSocket connection management
         3. UI updates (status, logging)
         4. Event handling (button clicks, WebSocket events)
         
         Uses ES modules (type="module") for clean import syntax.
    -->
    <script type="module">
        // =====================================================================
        // IMPORTS
        // =====================================================================
        
        // Import the Wasm module and exported functions from simulation.js
        // 
        // What each import does:
        // - init: Initializes the Wasm module (loads and compiles the .wasm file)
        // - handle_message: Passes WebSocket messages to Rust for processing
        // - console_log: Calls console.log from Rust (for demonstration)
        // - Shared memory functions for zero-copy batch transfer:
        //   - get_memory: Returns the Wasm linear memory object
        //   - get_packet_buffer_ptr: Returns pointer to the packet data buffer
        //   - get_packet_buffer_len: Returns current length of the buffer
        //   - allocate_packet_buffer: Pre-allocates buffer capacity
        //   - update_packet_buffer_from_binary: Updates buffer from binary data
        //   - update_packet_buffer_from_json: Updates buffer from JSON data
        import init, { 
            handle_message, 
            handle_binary, 
            console_log,
            get_memory,
            get_packet_buffer_ptr,
            get_packet_buffer_len,
            allocate_packet_buffer,
            update_packet_buffer_from_binary,
            update_packet_buffer_from_json,
            clear_packet_buffer
        } from './pkg/simulation.js';
        
        // =====================================================================
        // STATE VARIABLES
        // =====================================================================
        
        // WebSocket connection instance
        // null when disconnected, WebSocket object when connected
        let ws = null;
        
        // =====================================================================
        // DOM ELEMENT REFERENCES
        // =====================================================================
        
        // Cache DOM element references for performance
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const logContainer = document.getElementById('logContainer');
        const connectBtn = document.getElementById('connectBtn');
        const sendBtn = document.getElementById('sendBtn');
        
        // Canvas elements (Step 3)
        const canvas = document.getElementById('packetCanvas');
        const ctx = canvas.getContext('2d');
        
        // Stats elements
        const packetCountEl = document.getElementById('packetCount');
        const jsonSizeEl = document.getElementById('jsonSize');
        const drawTimeEl = document.getElementById('drawTime');
        const clearBtn = document.getElementById('clearBtn');
        
        // Performance tracking
        let totalPackets = 0;
        let lastJsonSize = 0;
        
        // =====================================================================
        // CANVAS DRAWING FUNCTIONS (Step 3)
        // =====================================================================
        
        /**
         * Draws a white square at the specified coordinates.
         * This function is called from Rust/Wasm via window.drawPacket().
         * 
         * @param {number} x - X coordinate (0-800)
         * @param {number} y - Y coordinate (0-600)
         */
        window.drawPacket = function(x, y) {
            ctx.fillStyle = '#ffffff';
            const size = 4;
            ctx.fillRect(x - size/2, y - size/2, size, size);
            totalPackets++;
            packetCountEl.textContent = totalPackets;
        };
        
        /**
         * Draws multiple packets at once for better performance.
         * This function is called from Rust/Wasm via window.drawPackets().
         * 
         * @param {Float64Array} coords - Flat array of [x0, y0, x1, y1, x2, y2, ...]
         */
        window.drawPackets = function(coords) {
            const startTime = performance.now();
            
            // Set drawing style once for all packets
            ctx.fillStyle = '#ffffff';
            const size = 4;
            
            // Draw each packet
            const packetCount = coords.length / 2;
            for (let i = 0; i < coords.length; i += 2) {
                const x = coords[i];
                const y = coords[i + 1];
                ctx.fillRect(x - size/2, y - size/2, size, size);
            }
            
            const drawTime = performance.now() - startTime;
            
            // Update stats
            totalPackets += packetCount;
            packetCountEl.textContent = totalPackets;
            drawTimeEl.textContent = drawTime.toFixed(2) + 'ms';
            
            addLog('JS', `Drew ${packetCount} packets in ${drawTime.toFixed(2)}ms`);
        };
        
        /**
         * Clears the canvas and resets the packet count.
         */
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            totalPackets = 0;
            packetCountEl.textContent = '0';
            drawTimeEl.textContent = '0ms';
            addLog('JS', 'Canvas cleared');
        }
        
        // =====================================================================
        // SHARED MEMORY ZERO-COPY DRAWING (High Performance)
        // =====================================================================
        
        /**
         * Draws packets using shared memory (zero-copy approach).
         * 
         * This function demonstrates the zero-copy batch transfer technique:
         * 1. Rust updates the packet buffer in its linear memory
         * 2. JavaScript gets a Float32Array view directly into that memory
         * 3. No data copying occurs - JS reads Rust's memory directly!
         * 
         * Performance benefits:
         * - No serialization/deserialization overhead
         * - No memory allocation for transfer
         * - Direct memory access is extremely fast
         * 
         * @param {number} packetCount - Number of packets to draw
         */
        function drawPacketsFromSharedMemory(packetCount) {
            const startTime = performance.now();
            
            // Get the Wasm linear memory object
            const memory = get_memory();
            
            // Get pointer and length from Rust
            const ptr = get_packet_buffer_ptr();
            const len = get_packet_buffer_len();
            
            // Create a Float32Array view directly into Wasm memory
            // This is ZERO-COPY: no data is moved, we're just creating a view!
            const coords = new Float32Array(memory.buffer, ptr, len);
            
            // Draw all packets using the shared memory view
            ctx.fillStyle = '#ffffff';
            const size = 4;
            
            for (let i = 0; i < len; i += 2) {
                const x = coords[i];
                const y = coords[i + 1];
                ctx.fillRect(x - size/2, y - size/2, size, size);
            }
            
            const drawTime = performance.now() - startTime;
            
            // Update stats
            totalPackets += packetCount;
            packetCountEl.textContent = totalPackets;
            drawTimeEl.textContent = drawTime.toFixed(2) + 'ms';
            
            addLog('JS', `[Zero-Copy] Drew ${packetCount} packets in ${drawTime.toFixed(2)}ms`);
        }
        
        /**
         * Handles binary message using shared memory approach.
         * 
         * Data flow:
         * 1. Binary data arrives via WebSocket
         * 2. Rust parses binary and updates shared buffer
         * 3. JS creates Float32Array view into Rust's memory (zero-copy!)
         * 4. JS draws packets directly from shared memory
         * 
         * @param {Uint8Array} bytes - Binary packet data
         */
        function handleBinaryWithSharedMemory(bytes) {
            const startTime = performance.now();
            
            // Rust parses binary data and updates the shared buffer
            // Returns the number of packets written
            const packetCount = update_packet_buffer_from_binary(bytes);
            
            const parseTime = performance.now() - startTime;
            
            // Draw using zero-copy shared memory access
            drawPacketsFromSharedMemory(packetCount);
            
            addLog('JS', `[Shared Memory] Parse: ${parseTime.toFixed(2)}ms, Packets: ${packetCount}`);
        }
        
        /**
         * Handles JSON message using shared memory approach.
         * 
         * Even for JSON, we can benefit from shared memory:
         * 1. Rust parses JSON and stores f32 coordinates in shared buffer
         * 2. JS reads directly from shared memory (zero-copy for drawing!)
         * 
         * @param {string} jsonData - JSON string containing packet array
         */
        function handleJsonWithSharedMemory(jsonData) {
            const startTime = performance.now();
            
            // Rust parses JSON and updates the shared buffer
            const packetCount = update_packet_buffer_from_json(jsonData);
            
            if (packetCount === 0) {
                // JSON parsing failed, fall back to original handler
                handle_message(jsonData);
                return;
            }
            
            const parseTime = performance.now() - startTime;
            
            // Draw using zero-copy shared memory access
            drawPacketsFromSharedMemory(packetCount);
            
            addLog('JS', `[Shared Memory JSON] Parse: ${parseTime.toFixed(2)}ms, Packets: ${packetCount}`);
        }
        
        // =====================================================================
        // UTILITY FUNCTIONS
        // =====================================================================
        
        /**
         * Adds a log entry to the log container.
         * 
         * Creates a new log entry with:
         * - Timestamp (HH:MM:SS format)
         * - Source label (JS, Rust, WS)
         * - Message text
         * 
         * @param {string} source - The source of the log ('JS', 'Rust', 'WS')
         * @param {string} message - The log message to display
         * 
         * @example
         * addLog('JS', 'Connecting to server...');
         * addLog('WS', 'Connection established!');
         * addLog('Rust', 'Message processed');
         */
        function addLog(source, message) {
            // Create a new div element for the log entry
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            
            // Get current time in Japanese locale format (HH:MM:SS)
            const time = new Date().toLocaleTimeString('ja-JP');
            
            // Build the log entry HTML
            // - log-time: Muted timestamp
            // - log-source: Color-coded source label
            // - message: The actual log content
            entry.innerHTML = `
                <span class="log-time">${time}</span>
                <span class="log-source ${source.toLowerCase()}">[${source}]</span>
                <span>${message}</span>
            `;
            
            // Append the entry to the log container
            logContainer.appendChild(entry);
            
            // Auto-scroll to show the latest log entry
            // scrollHeight is the total height of the content
            // scrollTop sets the scroll position
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        /**
         * Updates the UI to reflect the connection state.
         * 
         * Changes:
         * - Status dot color (red/green)
         * - Status text (Disconnected/Connected)
         * - Connect button text (Connect/Disconnect)
         * - Send button enabled state
         * 
         * @param {boolean} connected - Whether the WebSocket is connected
         */
        function setConnected(connected) {
            if (connected) {
                // Connected state
                statusDot.classList.add('connected');     // Green dot with glow
                statusText.textContent = 'Connected';
                connectBtn.textContent = 'Disconnect';
                sendBtn.disabled = false;                 // Enable send button
            } else {
                // Disconnected state
                statusDot.classList.remove('connected');  // Red dot
                statusText.textContent = 'Disconnected';
                connectBtn.textContent = 'Connect';
                sendBtn.disabled = true;                  // Disable send button
            }
        }
        
        // =====================================================================
        // WEBSOCKET FUNCTIONS
        // =====================================================================
        
        /**
         * Toggles the WebSocket connection.
         * 
         * If currently connected: closes the connection
         * If currently disconnected: opens a new connection
         * 
         * WebSocket lifecycle:
         * 1. new WebSocket(url) - Initiates connection
         * 2. onopen - Connection established
         * 3. onmessage - Message received from server
         * 4. onclose - Connection closed
         * 5. onerror - Error occurred
         */
        function connect() {
            // If already connected, close the connection and return
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
                return;
            }
            
            // Log the connection attempt
            addLog('JS', 'Connecting to ws://localhost:8080/ws...');
            
            // Create a new WebSocket connection
            // The URL must match the Go server's endpoint
            ws = new WebSocket('ws://localhost:8080/ws');
            
            // -------------------------------------------------------------
            // Event: Connection opened
            // -------------------------------------------------------------
            // Fired when the WebSocket handshake completes successfully
            ws.onopen = () => {
                addLog('WS', 'Connection established!');
                setConnected(true);
            };
            
            // -------------------------------------------------------------
            // Event: Message received
            // -------------------------------------------------------------
            // Fired when the server sends a message
            // 
            // Data flow (Shared Memory / Zero-Copy approach):
            // 1. Go Server -> WebSocket -> onmessage
            // 2. Rust parses data and updates shared buffer
            // 3. JS creates Float32Array view into Rust's memory (zero-copy!)
            // 4. JS draws packets directly from shared memory
            ws.onmessage = (event) => {
                // Check if the message is binary or text
                if (event.data instanceof Blob) {
                    // Binary message - use shared memory approach for best performance
                    event.data.arrayBuffer().then(buffer => {
                        const bytes = new Uint8Array(buffer);
                        handleBinaryWithSharedMemory(bytes);  // Zero-copy approach
                    });
                } else {
                    // Text message (JSON) - use shared memory for drawing
                    handleJsonWithSharedMemory(event.data);
                }
            };
            
            // -------------------------------------------------------------
            // Event: Connection closed
            // -------------------------------------------------------------
            // Fired when the connection is closed (by client or server)
            ws.onclose = () => {
                addLog('WS', 'Connection closed');
                setConnected(false);
            };
            
            // -------------------------------------------------------------
            // Event: Error occurred
            // -------------------------------------------------------------
            // Fired when a WebSocket error occurs
            // Note: The error event doesn't always have useful details
            ws.onerror = (error) => {
                addLog('WS', `Error: ${error.message || 'Connection failed'}`);
            };
        }
        
        /**
         * Sends a test message to the server.
         * 
         * The server (Go) is configured to echo messages back,
         * so we should receive the same message in onmessage.
         */
        function sendTest() {
            // Only send if connection is open
            if (ws && ws.readyState === WebSocket.OPEN) {
                const msg = 'Hello from browser!';
                
                // Send the message to the server
                ws.send(msg);
                
                addLog('JS', `Sent: "${msg}"`);
            }
        }
        
        // =====================================================================
        // WASM INITIALIZATION
        // =====================================================================
        
        /**
         * Initializes the Wasm module and sets up the application.
         * 
         * This is an async function because Wasm loading involves:
         * 1. Fetching the .wasm file from the server
         * 2. Compiling the WebAssembly bytecode
         * 3. Instantiating the module
         * 
         * The init() function is generated by wasm-bindgen and handles
         * all of these steps automatically.
         */
        async function run() {
            try {
                // Initialize the Wasm module
                // This fetches, compiles, and instantiates the .wasm file
                await init();
                
                addLog('JS', 'Wasm module loaded successfully!');
                
                // Pre-allocate shared memory buffer for packet data
                // This reserves space for up to 100,000 packets to avoid
                // reallocations during high-throughput data transfer
                const MAX_PACKETS = 100000;
                allocate_packet_buffer(MAX_PACKETS);
                addLog('JS', `[Shared Memory] Pre-allocated buffer for ${MAX_PACKETS} packets`);
                
                // Test the Wasm console_log function
                // This calls Rust code that logs to the browser console
                console_log('Hello from JavaScript!');
                
            } catch (e) {
                // Log any errors during Wasm initialization
                addLog('JS', `Failed to load Wasm: ${e.message}`);
                console.error(e);
            }
        }
        
        // =====================================================================
        // EVENT LISTENERS
        // =====================================================================
        
        // Button click handlers
        connectBtn.addEventListener('click', connect);
        sendBtn.addEventListener('click', sendTest);
        clearBtn.addEventListener('click', clearCanvas);
        
        // =====================================================================
        // APPLICATION ENTRY POINT
        // =====================================================================
        
        // Start the application by initializing Wasm
        // This runs immediately when the script is executed
        run();
    </script>
</body>
</html>
